init
main

\= AllocPtr 7
\= FirstStatePtr 6
\= StatePtr 5
\= TapePos 4

\= State.Name 0
\= State.FirstRulePtr 1
\= State.LastRulePtr 2
\= State.NextPtr 3
\= StateSize 4

\= Rule.NextPtr 0
\= Rule.NewSymbol 1
\= Rule.Move 2
\= Rule.NewStatePtr 3
\= Rule.Symbols 4
\= RuleSize 4

\= add-rule_StatePtr 8
\= add-rule_RulePtr 9

\= find-state_Name 10
\= find-state_CurrentPtr 11

\= alloc_CurrentPtr 12

\= read-rule_RulePtr 13
\= read-rule_Separator 14

\= find-rule_Symbol 15
\= find-rule_RulePtr 16

\= FirstAllocAddr 32

\:: end .

\: & \* (a, b) (a&b) *\ 0 ?? .
\: | \* (a, b) (a|b) *\ =(0) 1 @(0) ?? .
\: ~ \* (a) (~a) *\ 0 -1 ?? .
\% drop \* (a) () *\ 0 = .
\: xor \* (a, b) (a xor b) *\ $ =(0) ~ @(0) ?? .

\: + \\(a, b) (a + b)
  2= $ 1= 2@ xor
  &(1@ 2@) << $
  ?(:+ :+_exit) ^^
\:: +_exit
  $ =
.

\: ++ 1 + .
\: -- -1 ++ .
\: _ ~ ++ .
\: - _ + .

\: swap \\ (a b) (b a)
  =(0) =(1) @(0) @(1)
.

\: init
  FirstAllocAddr =(AllocPtr)
.

\: print
  $ ?(:print_put :print_end) ^^
  \:: print_put .> :print ^^
  \:: print_end $ =
.

\: alloc \\ (размер) (адрес)
  @(AllocPtr) $ =(alloc_CurrentPtr)
  + $ =(AllocPtr)
  &(0x8000) ?(:alloc_error :alloc_end) ^^
\:: alloc_error
  print(0 "Переполнение кучи") !! \\ а вдруг?
\:: alloc_end
  @(alloc_CurrentPtr)
.

\: alloc-state \\ () (адрес)
  alloc(StateSize)
.

\: alloc-rule \\ () (адрес)
  alloc(RuleSize)
.


\: find-state \\ (имя) (адрес)
  $ ?(:find-state_find :end) ^^

\:: find-state_find
  =(find-state_Name)
  @(FirstStatePtr)
  $ ?(:find-state_check :find-state_first) ^^

\:: find-state_first \\ (0)
  $ =
  @(:find-state_Name) alloc-state $ =(FirstStatePtr) =(+(State.Name)) @(FirstStatePtr)
  .

\:: find-state_check \\ (адрес)
  $ =(find-state_CurrentPtr)
  $ @(+(State.Name)) xor (@(find-state_Name)) ?(:find-state_next :end) ^^

\:: find-state_next \\ (адрес)
  @(+(State.NextPtr))
  $ ?(:find-state_check :find-state_none) ^^

\:: find-state_none \\ (0)
  $ =
  alloc-state
  $ @(find-state_CurrentPtr) +(State.NextPtr) =
  $ =(find-state_CurrentPtr)
  @(find-state_Name) @(find-state_CurrentPtr) +(State.Name) =
.


\: fix-separator \\ (символ) (символ|0)
  $ xor(@(read-rule_Separator)) ?(:end :fix-separator_nul) ^^

\:: fix-separator_nul
  drop 0
.


\: add-rule \\ (адрес состояния, адрес правила) ()
  =(add-rule_RulePtr) $ =(add-rule_StatePtr)
  +(State.LastRulePtr) $ @ $ ?(:add-rule_append :add-rule_first) ^^

\:: add-rule_append \\ (адрес указателя на последнее правило, указатель на последнее правило)
  +(Rule.NextPtr) @(add-rule_RulePtr) swap =
  @(add-rule_RulePtr) swap = .

\:: add-rule_first \\ (адрес указателя на последнее правило, указатель на последнее правило)
  drop @(add-rule_RulePtr) swap =
  @(add-rule_RulePtr) =(@(add-rule_StatePtr) +(State.FirstRulePtr))
.


\: read-symbols \\ (адрес буфера) ()
  $ .< fix-separator
  $ ?(:read-symbols_read :read-symbols_end) ^^

\:: read-symbols_read \\ (текущий адрес, текущий адрес, символ)
  swap = ++ :read-symbols ^^

\:: read-symbols_end
  drop drop
  ++ =(AllocPtr)
.


\: read-rule \\ (имя) ()
  find-state \\ (адрес состояния)
  alloc-rule $ =(read-rule_RulePtr) \\ (адрес состояния, адрес правила)
  add-rule \\ ()
  .< =(read-rule_Separator) \\ ()
  @(read-rule_RulePtr)
  $ +(Rule.Symbols) read-symbols
  $ .< fix-separator swap +(Rule.NewSymbol) =
  $ .< fix-separator find-state swap +(Rule.NewStatePtr) = $
  .< $ xor("+") ?(:read-rule_not-forward :read-rule_forward) ^^

\:: read-rule_forward \\ (адрес правила, символ)
  drop 1 read-rule_move

\:: read-rule_not-forward \\ (адрес правила, символ)
  xor("-") ?(0 -1)

\:: read-rule_move \\ (адрес правила, направление)
  swap +(Rule.Move) =
  drop

\:: read-rule_find-end
  .< xor(10) ?(:read-rule_find-end :end) ^^
.

\: read-rules
  .< $ xor(10) ?(:read-rules_read :read-rules_end) ^^

\:: read-rules_read
  read-rule :read-rules ^^

\:: read-rules_end
  drop
  @(FirstStatePtr) =(StatePtr)
.


\: read-tape
  0x8000 $ =(TapePos) $ " " swap =

\:: read-tape_cycle
  $ .< $ ?(:read-tape_read :read-tape_end) ^^

\:: read-tape_read \\ (адрес, адрес, символ)
  swap = ++
  read-tape_cycle

\:: read-tape_end \\ (адрес, адрес, 0)
  = drop
.


\: find-rule \\ (символ) (адрес правила)
  =(find-rule_Symbol)
  @(StatePtr) +(State.FirstRulePtr) @

\:: find-rule_cycle
  $ =(find-rule_RulePtr)
  $ ?(:find-rule_check :find-rule_error) ^^

\:: find-rule_check
  +(Rule.Symbols)

\:: find-rule_check-cycle
  $ @
  $ ?(:find-rule_compare :find-rule_next) ^^

\::find-rule_compare
  xor(@(find-rule_Symbol)) ?(:find-rule_next-symbol :find-rule_end) ^^

\:: find-rule_next-symbol
  ++ find-rule_check-cycle

\:: find-rule_next
  $ = drop
  @(find-rule_RulePtr) +(Rule.NextPtr) @ find-rule_cycle

\:: find-rule_error
  print(0 "Не найдено правило") $ = !!

\:: find-rule_end
  drop @(find-rule_RulePtr)
.


\: move-head \\ (направление) ()
  $ ?(:move-head_move :move-head_end) ^^

\:: move-head_move
  @(@(TapePos)) + $ =(TapePos)
  $ @ ?(:move-head_end :move-head_fix) ^^

\:: move-head_fix

\:: move-head_end
  $ =
.

\: run
  @(@(TapePos))

.

\:: main

read-rules
read-tape
run
